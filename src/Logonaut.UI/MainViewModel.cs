using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Reactive.Concurrency; // For IScheduler, DispatcherScheduler
using System.Reactive.Disposables; // For CompositeDisposable
using System.Reactive.Linq; // For Rx operators
using System.Reactive.Subjects; // For Subject
using System.Windows.Threading; // Add this for WPF's Dispatcher
using System.Text.RegularExpressions;
using System.Threading; // For SynchronizationContext
using System.Windows; // For Visibility, MessageBox
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Logonaut.Common;
using Logonaut.Core;
using Logonaut.Filters;
using Logonaut.LogTailing;
using Logonaut.UI.Services;

namespace Logonaut.UI.ViewModels
{
    public partial class MainViewModel : ObservableObject, IDisposable
    {
        public ThemeViewModel Theme { get; } = new();

        // The complete log text. This will only be used as an input to the filter task.
        public LogDocument LogDoc { get; } = new();

        public ObservableCollection<FilteredLogLine> FilteredLogLines { get; } = new();

        // Property for binding to AvalonEdit (holds only the text content)
        [ObservableProperty]
        private string _logText = string.Empty; // Backing field generated by ObservableProperty

        [ObservableProperty]
        [NotifyCanExecuteChangedFor(nameof(PreviousSearchCommand))] // Use generated attribute
        [NotifyCanExecuteChangedFor(nameof(NextSearchCommand))]    // Use generated attribute
        private string _searchText = ""; // Backing field generated by ObservableProperty

        [ObservableProperty]
        private string? _currentLogFilePath; // Backing field generated by ObservableProperty

        public ObservableCollection<FilterViewModel> FilterProfiles { get; } = new();

        // The currently selected filter in the tree.
        [ObservableProperty]
        [NotifyCanExecuteChangedFor(nameof(RemoveFilterCommand))]
        [NotifyCanExecuteChangedFor(nameof(ToggleEditCommand))]
        private FilterViewModel? _selectedFilter; // Backing field generated by ObservableProperty

        private readonly IFileDialogService _fileDialogService;

        // --- Add a flag to prevent scheduling multiple updates ---
        private bool _logTextUpdateScheduled = false;
        private readonly object _logTextUpdateLock = new object(); // Lock for the flag

        // --- Reactive Fields ---
        private readonly CompositeDisposable _disposables = new(); // Manages Rx subscriptions
        private readonly Subject<System.Reactive.Unit> _filterChangedSubject = new(); // Publishes filter change events
        private long _currentLineIndex = 0; // Tracks original line numbers for incoming lines
        private const int LineBufferSize = 50; // How many lines to buffer before filtering
        private readonly TimeSpan _lineBufferTimeSpan = TimeSpan.FromMilliseconds(100); // Max time before filtering buffer
        private readonly TimeSpan _filterDebounceTime = TimeSpan.FromMilliseconds(300); // Debounce filter changes

        // --- Schedulers for Rx ---
        // Use TaskPoolScheduler for background work, DispatcherScheduler for UI updates
        private readonly IScheduler _backgroundScheduler = TaskPoolScheduler.Default;

        private readonly SynchronizationContext _uiContext;

        public MainViewModel(IFileDialogService? fileDialogService = null)
        {
            _fileDialogService = fileDialogService ?? new FileDialogService();

            // --- Capture Synchronization Context ---
            _uiContext = SynchronizationContext.Current ?? throw new InvalidOperationException("Could not capture SynchronizationContext. Ensure ViewModel is created on the UI thread."); // <<<<< ADDED

            // --- Initialize Rx Pipelines ---
            InitializeFilteringPipelines();
        }

        private void InitializeFilteringPipelines()
        {
            // --- Incremental Filtering Pipeline ---
            var incrementalSubscription = LogTailerManager.Instance.LogLines
                // ... (Select and Buffer steps remain the same) ...
                .Select(line =>
                {
                    var lineWithIndex = new { LineText = line, OriginalIndex = Interlocked.Increment(ref _currentLineIndex) };
                    LogDoc.AppendLine(line);
                    return lineWithIndex;
                })
                .Buffer(_lineBufferTimeSpan, LineBufferSize, _backgroundScheduler)
                .Where(buffer => buffer.Count > 0)
                .Select(buffer =>
                {
                    IFilter currentFilter = GetCurrentFilter();
                    return buffer
                        .Select(item => new { Item = item, IsMatch = currentFilter.IsMatch(item.LineText) })
                        .Where(result => result.IsMatch)
                        .Select(result => new FilteredLogLine((int)result.Item.OriginalIndex, result.Item.LineText))
                        .ToList();
                })
                .Where(filteredLines => filteredLines.Count > 0)
                 // --- Use SynchronizationContext for ObserveOn ---
                .ObserveOn(_uiContext) // <<<<< CHANGED
                .Subscribe(
                    matchedLines => AddFilteredLines(matchedLines),
                    ex => HandlePipelineError("Incremental Filtering Error", ex)
                );

            _disposables.Add(incrementalSubscription);

            // --- Full Re-Filtering Pipeline (Triggered by Filter Changes) ---
            var fullRefilterSubscription = _filterChangedSubject
                .Throttle(_filterDebounceTime, _backgroundScheduler)
                .Select(_ =>
                {
                    IFilter currentFilter = GetCurrentFilter();
                    int contextLines = 1;
                    var logDocSnapshot = LogDoc.ToList();
                    var doc = new LogDocument();
                    doc.AddInitialLines(string.Join(Environment.NewLine, logDocSnapshot));
                    return FilterEngine.ApplyFilters(doc, currentFilter, contextLines);
                })
                 // --- Use SynchronizationContext for ObserveOn ---
                .ObserveOn(_uiContext) // <<<<< CHANGED
                .Subscribe(
                    newFilteredLines => ReplaceFilteredLines(newFilteredLines),
                    ex => HandlePipelineError("Full Re-Filtering Error", ex)
                );

            _disposables.Add(fullRefilterSubscription);
            _disposables.Add(_filterChangedSubject);

            TriggerFullRefilter();
        }

        // --- UI Update Methods (Called on UI Thread by Rx) ---

        private void AddFilteredLines(List<FilteredLogLine> linesToAdd)
        {
            // Add lines directly
            foreach (var line in linesToAdd)
            {
                FilteredLogLines.Add(line);
            }
            // Schedule the update instead of calling directly
            ScheduleLogTextUpdate(); // <<<<< CHANGED
        }

        private void ReplaceFilteredLines(IReadOnlyList<FilteredLogLine> newLines)
        {
            FilteredLogLines.Clear();
            foreach (var line in newLines)
            {
                FilteredLogLines.Add(line);
            }
            // Schedule the update instead of calling directly
            ScheduleLogTextUpdate(); // <<<<< CHANGED
        }

        // --- Schedule the UpdateLogText call ---
        private void ScheduleLogTextUpdate()
        {
            lock (_logTextUpdateLock)
            {
                if (!_logTextUpdateScheduled)
                {
                    _logTextUpdateScheduled = true;
                    // Post the update to run after the current dispatcher operation finishes
                    _uiContext.Post(_ =>
                    {
                        lock (_logTextUpdateLock)
                        {
                            _logTextUpdateScheduled = false; // Reset flag before executing
                        }
                        UpdateLogTextInternal(); // Call the internal method
                    }, null);
                }
            }
        }

        // --- Renamed original UpdateLogText ---
        private void UpdateLogTextInternal() // <<<<< RENAMED
        {
            try
            {
                 // Create a temporary list to avoid issues if FilteredLogLines is modified
                 // by another thread right after this line (though UI context makes this less likely)
                var textOnly = FilteredLogLines.Select(line => line.Text).ToList();
                LogText = string.Join(Environment.NewLine, textOnly);
            }
            catch (InvalidOperationException ioex)
            {
                // Catch the specific exception if it somehow still occurs
                Debug.WriteLine($"Error during UpdateLogTextInternal (Collection modified?): {ioex}");
                 // Maybe schedule another update? Or log more severely.
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Generic error during UpdateLogTextInternal: {ex}");
            }
        }


        // --- Helper Methods ---
        // --- Helper Methods ---

        private IFilter GetCurrentFilter()
        {
            // **Potential Improvement for Strict Thread Safety**
            // If FilterProfiles were modified extremely rapidly from the UI concurrently
            // with this background read, it *could* be an issue. A safer pattern:
            // 1. On UI thread (e.g., before Select in Rx pipeline or via ObserveOn), get filter.
            // 2. Pass the filter instance (or its immutable representation) to the background task.
            // For now, assuming UI thread modifications are infrequent enough relative to reads.
            return FilterProfiles.FirstOrDefault()?.FilterModel ?? new TrueFilter();
        }

        private void TriggerFullRefilter()
        {
            _filterChangedSubject.OnNext(System.Reactive.Unit.Default);
        }

        private void HandlePipelineError(string contextMessage, Exception ex)
        {
            Debug.WriteLine($"{contextMessage}: {ex}");
            // Consider logging or showing a user-friendly error message on the UI thread
            // Dispatcher.CurrentDispatcher.InvokeAsync(() => { /* Show error */ });
        }

        // --- Commands ---

        [RelayCommand] private void AddSubstringFilter() => AddFilter(new SubstringFilter(""));
        [RelayCommand] private void AddRegexFilter() => AddFilter(new RegexFilter(".*"));
        [RelayCommand] private void AddAndFilter() => AddFilter(new AndFilter());
        [RelayCommand] private void AddOrFilter() => AddFilter(new OrFilter());
        [RelayCommand] private void AddNorFilter() => AddFilter(new NorFilter());

        private void AddFilter(IFilter filter)
        {
             // Create with callback injected
            var newFilterVM = new FilterViewModel(filter, TriggerFullRefilter);

            if (FilterProfiles.Count == 0)
            {
                // If no filter exists, make this the root.
                FilterProfiles.Add(newFilterVM);
                SelectedFilter = newFilterVM;
            }
            else if (SelectedFilter != null && SelectedFilter.FilterModel is CompositeFilter)
            {
                SelectedFilter.AddChildFilter(filter); // AddChildFilter now passes callback
            }
            else
            {
                 MessageBox.Show(
                     SelectedFilter == null
                     ? "Please select a filter node first."
                     : "Selected filter is not a composite filter (And, Or, Nor). Cannot add a child filter here.",
                     "Add Filter Information", MessageBoxButton.OK, MessageBoxImage.Information);
                return; // Don't trigger update if nothing was added
            }
             UpdateFilterSubstringsCommand.Execute(null); // Update highlighting
             TriggerFullRefilter(); // Trigger full re-filter
        }

        [RelayCommand(CanExecute = nameof(CanRemoveFilter))]
        private void RemoveFilter()
        {
            if (SelectedFilter == null) return;

            FilterViewModel? parent = SelectedFilter.Parent;

            if (FilterProfiles.Contains(SelectedFilter))
            {
                FilterProfiles.Remove(SelectedFilter);
                SelectedFilter = null;
            }
            else if (parent != null)
            {
                parent.RemoveChild(SelectedFilter);
                SelectedFilter = parent; // Select parent after removing child
            }

            UpdateFilterSubstringsCommand.Execute(null); // Update highlighting
            TriggerFullRefilter(); // Trigger full re-filter
        }
        private bool CanRemoveFilter() => SelectedFilter != null;

        [RelayCommand(CanExecute = nameof(CanToggleEdit))]
        private void ToggleEdit()
        {
            if (SelectedFilter?.IsEditable ?? false) // Null-conditional access
            {
                if (SelectedFilter.IsNotEditing)
                    SelectedFilter.BeginEdit();
                else
                    SelectedFilter.EndEdit(); // EndEdit now calls the callback -> TriggerFullRefilter
            }
        }
        private bool CanToggleEdit() => SelectedFilter?.IsEditable ?? false;

        partial void OnSelectedFilterChanged(FilterViewModel? oldValue, FilterViewModel? newValue)
        {
             // End edit mode if selection changes away from an editable filter that was editing
            if (oldValue != null && oldValue.IsEditing)
            {
                 oldValue.EndEditCommand.Execute(null);
            }

            // Update IsSelected for visual feedback in TreeView workaround
            if (oldValue != null) oldValue.IsSelected = false;
            if (newValue != null) newValue.IsSelected = true;
        }


        // TODO: Implement actual search logic
        [RelayCommand(CanExecute = nameof(CanSearch))]
        private void PreviousSearch() { Debug.WriteLine("Previous search triggered."); }
        [RelayCommand(CanExecute = nameof(CanSearch))]
        private void NextSearch() { Debug.WriteLine("Next search triggered."); }
        private bool CanSearch() => !string.IsNullOrWhiteSpace(SearchText);


        [RelayCommand]
        private void OpenLogFile()
        {
            string? selectedFile = _fileDialogService.OpenFile("Select a log file", "Log Files|*.log;*.txt|All Files|*.*");
            if (string.IsNullOrEmpty(selectedFile))
                return;

            ResetStateForNewFile(); // Clear old data

            CurrentLogFilePath = selectedFile;

            try
            {
                LogTailerManager.Instance.ChangeFile(selectedFile);
                // Filtering pipelines are already running and will pick up new lines
            }
            catch (Exception ex)
            {
                 MessageBox.Show($"Error opening or monitoring log file '{selectedFile}':\n{ex.Message}", "File Error", MessageBoxButton.OK, MessageBoxImage.Error);
                 CurrentLogFilePath = null; // Reset path on error
            }
        }

        private void ResetStateForNewFile()
        {
            Interlocked.Exchange(ref _currentLineIndex, 0);
            LogDoc.Clear();

            // Use Post to ensure Clear happens on UI thread and AFTER current operations
            _uiContext.Post(_ => {
                FilteredLogLines.Clear();
                // Instead of setting LogText="", schedule an update which will do it correctly based on the now empty collection
                ScheduleLogTextUpdate(); // <<<<< CHANGED
            }, null);

            TriggerFullRefilter();
        }

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(IsCustomLineNumberMarginVisible))]
        private bool _showLineNumbers = true;
        public Visibility IsCustomLineNumberMarginVisible => ShowLineNumbers ? Visibility.Visible : Visibility.Collapsed;

        [ObservableProperty]
        private bool _highlightTimestamps = true;


        [RelayCommand]
        private void UpdateFilterSubstrings()
        {
            // Create a new collection instead of clearing the existing one (MVVM best practice)
            var newFilterSubstrings = new ObservableCollection<string>();

            // Traverse the filter tree and collect patterns for highlighting
            if (FilterProfiles.Count > 0)
            {
                TraverseFilterTreeForHighlighting(FilterProfiles[0], newFilterSubstrings);
            }
            FilterSubstrings = newFilterSubstrings;
        }

        private void TraverseFilterTreeForHighlighting(FilterViewModel filterViewModel, ObservableCollection<string> patterns)
        {
            // Only consider enabled filters for highlighting
            if (!filterViewModel.Enabled) return;

            string? pattern = null;
            bool isRegex = false;

            if (filterViewModel.FilterModel is SubstringFilter sf && !string.IsNullOrEmpty(sf.Value))
            {
                pattern = Regex.Escape(sf.Value);
                isRegex = false;
            }
            else if (filterViewModel.FilterModel is RegexFilter rf && !string.IsNullOrEmpty(rf.Value))
            {
                pattern = rf.Value;
                isRegex = true;
            }

            if (pattern != null)
            {
                 try
                 {
                     if (isRegex) { _ = new Regex(pattern); } // Validate regex
                     if (!patterns.Contains(pattern)) // Avoid duplicates
                         patterns.Add(pattern);
                 }
                 catch (ArgumentException ex)
                 {
                     Debug.WriteLine($"Invalid regex pattern skipped for highlighting: '{pattern}'. Error: {ex.Message}");
                 }
            }

            foreach (var childFilter in filterViewModel.Children)
            {
                TraverseFilterTreeForHighlighting(childFilter, patterns);
            }
        }


        [ObservableProperty]
        private ObservableCollection<string> _filterSubstrings = new();


        // --- IDisposable Implementation ---
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                _disposables.Dispose(); // Dispose all Rx subscriptions
                LogTailerManager.Instance.Dispose(); // Dispose the singleton manager
                 Debug.WriteLine("MainViewModel Disposed.");
            }
        }

         // Make MainViewModel responsible for Cleanup during Window Closing
        // Called from MainWindow.xaml.cs
        public void Cleanup()
        {
            Dispose();
        }
    }
}