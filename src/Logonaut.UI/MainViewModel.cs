using System.Collections.ObjectModel;
using System.Text.RegularExpressions;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Logonaut.UI.Services;
using Logonaut.LogTailing;
using Logonaut.Filters;
using Logonaut.Common;
using Logonaut.Core;
using System.Diagnostics; // For Debug.WriteLine
using System.Windows; // For Visibility

namespace Logonaut.UI.ViewModels
{
    public partial class MainViewModel : ObservableObject
    {
        public ThemeViewModel Theme { get; } = new();

        // The complete log text. This will only be used as an input to the filter task.
        public LogDocument LogDoc { get; } = new();

        [ObservableProperty]
        private IReadOnlyList<FilteredLogLine> _filteredLogLines = new List<FilteredLogLine>().AsReadOnly();

        // Property for binding to AvalonEdit (holds only the text content)
        [ObservableProperty]
        private string _logText = string.Empty;

        [ObservableProperty]
        private string _searchText = ""; // Use backing field generated by ObservableProperty

        [ObservableProperty]
        private string? _currentLogFilePath; // Use backing field generated by ObservableProperty

        public ObservableCollection<FilterViewModel> FilterProfiles { get; } = new();

        // The currently selected filter in the tree.
        [ObservableProperty]
        [NotifyCanExecuteChangedFor(nameof(RemoveFilterCommand))] // Notify dependent commands
        [NotifyCanExecuteChangedFor(nameof(ToggleEditCommand))]
        private FilterViewModel? _selectedFilter; // Use backing field generated by ObservableProperty

        private readonly IFileDialogService _fileDialogService;

        // signal cancellation requests for the background filtering task
        private CancellationTokenSource? _cts;

        public MainViewModel(IFileDialogService? fileDialogService = null)
        {
            _fileDialogService = fileDialogService ?? new FileDialogService();

            // Subscribe to log lines from the tailer manager.
            LogTailerManager.Instance.LogLines.Subscribe(
                line => { LogDoc.AppendLine(line); }, // Append to raw document
                ex => {
                    // TODO: Implement proper UI error feedback for tailing errors
                    Debug.WriteLine($"Log Tailing Error: {ex.Message}");
                    // Consider showing a status bar message or dialog
                    App.Current.Dispatcher.Invoke(() => {
                        // Example: Show error (could be improved with a dedicated status service)
                        // MessageBox.Show($"Error reading log file: {ex.Message}", "File Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    });
                }
                // No need to update LogText/FilteredLogLines here directly, background task handles it
            );
            StartBackgroundFiltering();
        }

        // Method to update the LogText property from the filtered log lines
        private void UpdateLogText()
        {
            // Extract only the text part for AvalonEdit's main content binding
            var textOnly = FilteredLogLines.Select(line => line.Text);
            LogText = string.Join(Environment.NewLine, textOnly);
        }

        // Separate commands for adding different types of filters.
        [RelayCommand]
        private void AddSubstringFilter() { AddFilter(new SubstringFilter("")); }
        [RelayCommand]
        private void AddRegexFilter() { AddFilter(new RegexFilter(".*")); }
        [RelayCommand]
        private void AddAndFilter() { AddFilter(new AndFilter()); }
        [RelayCommand]
        private void AddOrFilter() { AddFilter(new OrFilter()); }
        [RelayCommand]
        private void AddNorFilter() { AddFilter(new NorFilter()); }

        private void AddFilter(IFilter filter)
        {
            var newFilterVM = new FilterViewModel(filter);

            if (FilterProfiles.Count == 0)
            {
                // If no filter exists, make this the root.
                FilterProfiles.Add(newFilterVM);
                SelectedFilter = newFilterVM; // Auto-select the new root
            }
            else if (SelectedFilter != null)
            {
                // Add to the currently selected composite filter.
                if (SelectedFilter.FilterModel is CompositeFilter) // No need to cast here
                {
                    SelectedFilter.AddChildFilter(filter);
                    // TODO: Optionally expand the parent to show the new child
                    // SelectedFilter.IsExpanded = true; // If IsExpanded is an observable property on FilterViewModel
                }
                else
                {
                    // Popup an error message
                    MessageBox.Show("Selected filter is not a composite filter (And, Or, Nor). Cannot add a child filter here.", "Add Filter Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
             else
            {
                 // Root exists, but nothing is selected.
                 MessageBox.Show("Please select a composite filter (And, Or, Nor) in the tree where you want to add the new filter.", "Add Filter Information", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            // No need to trigger filtering explicitly, background task will pick it up.
            // Trigger highlighting update if the new filter might affect it
             UpdateFilterSubstringsCommand.Execute(null);
        }

        [RelayCommand(CanExecute = nameof(CanRemoveFilter))]
        private void RemoveFilter()
        {
            if (SelectedFilter == null) return; // Should be blocked by CanExecute

            FilterViewModel? parent = SelectedFilter.Parent; // Store parent before removal

            if (FilterProfiles.Contains(SelectedFilter))
            {
                // Removing a root filter.
                FilterProfiles.Remove(SelectedFilter);
                SelectedFilter = null; // Clear selection if root was removed
            }
            else if (parent != null)
            {
                // Removing a child filter.
                parent.RemoveChild(SelectedFilter);
                SelectedFilter = parent; // Select the parent after removing child
            }
            UpdateFilterSubstringsCommand.Execute(null); // Update highlighting
        }
        private bool CanRemoveFilter() => SelectedFilter != null;

        [RelayCommand(CanExecute = nameof(CanToggleEdit))]
        private void ToggleEdit()
        {
            if (SelectedFilter != null && SelectedFilter.IsEditable)
            {
                if (SelectedFilter.IsNotEditing)
                    SelectedFilter.BeginEdit();
                else
                    SelectedFilter.EndEdit();
            }
        }
        private bool CanToggleEdit() => SelectedFilter != null && SelectedFilter.IsEditable;


        // Track previous selection for IsSelected binding simulation in TreeView
        private FilterViewModel? _previousSelectedFilter;
        // This is called when SelectedFilter changes due to [ObservableProperty]
        partial void OnSelectedFilterChanged(FilterViewModel? oldValue, FilterViewModel? newValue)
        {
            // Update IsSelected for visual feedback in TreeView workaround
            if (oldValue != null)
                oldValue.IsSelected = false;
            if (newValue != null)
                newValue.IsSelected = true;

            // CanExecuteChanged is notified automatically via [NotifyCanExecuteChangedFor] attributes
        }


        // TODO: Implement actual search logic using AvalonEdit's API or other search strategy
        [RelayCommand(CanExecute = nameof(CanSearch))]
        private void PreviousSearch() { /* Implement search backward */ Debug.WriteLine("Previous search triggered."); }

        [RelayCommand(CanExecute = nameof(CanSearch))]
        private void NextSearch() { /* Implement search forward */ Debug.WriteLine("Next search triggered."); }

        // This is called when SearchText changes due to [ObservableProperty]
        partial void OnSearchTextChanged(string value)
        {
            // CanExecuteChanged is notified automatically via [NotifyCanExecuteChangedFor] on the commands
        }
        // Use [NotifyCanExecuteChangedFor] on search commands instead
        private bool CanSearch() => !string.IsNullOrWhiteSpace(SearchText);


        [RelayCommand]
        private void OpenLogFile()
        {
            string? selectedFile = _fileDialogService.OpenFile("Select a log file", "Log Files|*.log;*.txt|All Files|*.*");
            if (string.IsNullOrEmpty(selectedFile))
                return;

            // --- Reset state before opening new file ---
            LogDoc.Clear();
            // Reset FilteredLogLines on UI thread
            App.Current.Dispatcher.Invoke(() => {
                FilteredLogLines = new List<FilteredLogLine>().AsReadOnly();
                LogText = string.Empty; // Clear editor content immediately
            });
            // If FilterProfiles should be cleared per file, do it here:
            // FilterProfiles.Clear();
            // SelectedFilter = null;
            // UpdateFilterSubstringsCommand.Execute(null);

            CurrentLogFilePath = selectedFile; // Update displayed path
            // --- End Reset ---

            try
            {
                 // Stop existing tailer/filter before starting new one
                StopBackgroundFiltering(); // Ensure previous task is cancelled
                // Dispose previous tailer implicitly via ChangeFile
                LogTailerManager.Instance.ChangeFile(selectedFile);
                // Restart filtering for the new file
                StartBackgroundFiltering();
            }
            catch (Exception ex)
            {
                 MessageBox.Show($"Error opening or monitoring log file '{selectedFile}':\n{ex.Message}", "File Error", MessageBoxButton.OK, MessageBoxImage.Error);
                 CurrentLogFilePath = null; // Reset path on error
            }
        }

        private void StartBackgroundFiltering()
        {
             StopBackgroundFiltering(); // Ensure any previous task is stopped first

            _cts = new CancellationTokenSource();
            var token = _cts.Token;
             Debug.WriteLine("Starting background filtering task...");

            Task.Run(async () =>
            {
                while (!token.IsCancellationRequested)
                {
                    try
                    {
                        // Get the current filter tree (use TrueFilter if no profiles exist)
                        IFilter currentFilter = FilterProfiles.FirstOrDefault()?.FilterModel ?? new TrueFilter();
                        int contextLines = 1; // TODO: Make context lines configurable via UI/Settings

                        // Apply filtering (now returns IReadOnlyList<FilteredLogLine>)
                        var newFilteredData = FilterEngine.ApplyFilters(LogDoc, currentFilter, contextLines);

                        // Update the FilteredLogLines on the UI thread.
                        // Check cancellation token *before* dispatching to UI thread
                        if (token.IsCancellationRequested) break;

                        await App.Current.Dispatcher.InvokeAsync(() =>
                        {
                            // Check token again *inside* dispatcher callback to handle race conditions
                            if (token.IsCancellationRequested) return;

                            FilteredLogLines = newFilteredData; // Update the observable property

                            // Update the LogText property after filtering is complete
                            UpdateLogText();
                        }, System.Windows.Threading.DispatcherPriority.Background); // Use Background priority

                        // Wait a bit before next update (throttling)
                        await Task.Delay(250, token); // Use token for delay cancellation
                    }
                    catch (OperationCanceledException)
                    {
                        Debug.WriteLine("Background filtering task cancelled.");
                        break; // Exit loop cleanly
                    }
                    catch (Exception ex)
                    {
                         Debug.WriteLine($"Background Filtering Error: {ex}");
                         // Consider logging more formally or providing UI feedback
                         // Add a delay to prevent tight error loops
                         await Task.Delay(1000, token);
                    }
                }
                 Debug.WriteLine("Background filtering task stopped.");
            }, token);
        }

        public void StopBackgroundFiltering()
        {
            if (_cts != null && !_cts.IsCancellationRequested)
            {
                 Debug.WriteLine("Requesting background filtering task stop...");
                _cts.Cancel();
                // Optional: Wait briefly for task to acknowledge cancellation? Not usually necessary.
            }
            _cts?.Dispose(); // Dispose the CancellationTokenSource
            _cts = null;
        }

        // Controls visibility of the *custom* line number margin
        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(IsCustomLineNumberMarginVisible))] // Notify dependent property
        private bool _showLineNumbers = true; // Use backing field generated by ObservableProperty

        // Property bound to the custom margin's Visibility in XAML
        public Visibility IsCustomLineNumberMarginVisible => ShowLineNumbers ? Visibility.Visible : Visibility.Collapsed;


        [ObservableProperty]
        private bool _highlightTimestamps = true; // Use backing field generated by ObservableProperty

        [RelayCommand]
        private void UpdateFilterSubstrings()
        {
            // Create a new collection instead of clearing the existing one (MVVM best practice)
            var newFilterSubstrings = new ObservableCollection<string>();

            // Traverse the filter tree and collect patterns for highlighting
            if (FilterProfiles.Count > 0)
            {
                TraverseFilterTree(FilterProfiles[0]);
            }

            // Set the property to the new collection to trigger the dependency property change in AvalonEditHelper
            FilterSubstrings = newFilterSubstrings;

            void TraverseFilterTree(FilterViewModel filterViewModel)
            {
                // Only consider enabled filters for highlighting
                if (!filterViewModel.Enabled) return;

                string? pattern = null;
                bool isRegex = false;

                // Check filter type and get value
                if (filterViewModel.FilterModel is SubstringFilter substringFilter && !string.IsNullOrEmpty(substringFilter.Value))
                {
                    pattern = Regex.Escape(substringFilter.Value); // Escape for regex safety
                    isRegex = false; // It's treated as literal text
                }
                else if (filterViewModel.FilterModel is RegexFilter regexFilter && !string.IsNullOrEmpty(regexFilter.Value))
                {
                    pattern = regexFilter.Value; // Use directly as regex
                    isRegex = true;
                }

                // Add valid patterns to the list
                if (pattern != null)
                {
                     try
                     {
                         // Validate if it's supposed to be a regex
                         if (isRegex) { _ = new Regex(pattern); } // Try compiling regex

                         newFilterSubstrings.Add(pattern);
                     }
                     catch (ArgumentException ex)
                     {
                         // Log or notify user about invalid regex from filter definition
                         Debug.WriteLine($"Invalid regex pattern in filter skipped for highlighting: '{pattern}'. Error: {ex.Message}");
                     }
                }

                // Recursively process children for composite filters
                foreach (var childFilter in filterViewModel.Children)
                {
                    TraverseFilterTree(childFilter);
                }
            }
        }

        // Collection bound to AvalonEditHelper for filter highlighting
        [ObservableProperty]
        private ObservableCollection<string> _filterSubstrings = new(); // Use backing field

        // Cleanup logic called when the application/window is closing
        public void Cleanup()
        {
            Debug.WriteLine("MainViewModel Cleanup starting...");
            StopBackgroundFiltering(); // Ensure background task is stopped
            LogTailerManager.Instance.Dispose(); // Dispose the tailer manager
            Debug.WriteLine("MainViewModel Cleanup finished.");
            // TODO: Add saving of configuration/settings here
        }
    }
}
